####################################
# Base library of Kage Tools
# Copyright CEP(Kage Park)
# License : GPL
#   Since : March 1994
####################################
####################################
#Sample base script info
####################################
##Kage Library  - <name>
##\$lib_ver$:0.0.1
#_k_loaded_${name}(){
#   local null
#}
##_k_${name}(){
##   start code here
##}
##_k_${name}_close(){
## close code here
##}
####################################

error_return() {
  return 1
}

_k_load() {
  local name  opt
  name=$1
  opt=$2
  if [ $# -ne 1 ]; then
     error_return "_k_load <lib name>"
  else
     if [ -f $_K_LIB/${tag}${name}.so ]; then
         if [ "$opt" == "-f" ]; then
             . $_K_LIB/${tag}${name}.so
             declare -F -p | cut -d " " -f 3 | grep "^_k_${name}$" > /dev/null 2>&1 && _k_${name}
         elif ! _k_list_lib | grep "^$name$" > /dev/null ; then
             . $_K_LIB/${tag}${name}.so
             declare -F -p | cut -d " " -f 3 | grep "^_k_${name}$" > /dev/null 2>&1 && _k_${name}
         fi
     elif [ -f $_K_LIB/${name} ]; then
         . $_K_LIB/${name}
     else
        return 1
     fi
  fi
  return 0
}

_k_unload() {
  local name ln opt
  name=$1
  opt=$2
  if [ $# -ne 1 ]; then
     error_return "_k_unload <lib name>"
  else
     declare -F -p | cut -d " " -f 3 | grep "^_k_${name}_close$" > /dev/null 2>&1 && _k_${name}_close
     for ln in $(grep "^_k_" $_K_LIB/${tag}${name}.so | awk -F\( '{print $1}'); do
        unset $ln > /dev/null 2>&1
     done
  fi
}

_k_lexec() {
    #ex : _k_lexec <lib name> <function> <options...>
    local klib preload _k_preload_list pll _k_preload_list_arr
    klib=$1
    shift 1
    _k_load $klib
    if [ "$?" == "0" ]; then
        _k_preload_list="$_k_preload_list $klib"
    fi

    _k_preload $klib

    #EXEC
    $*

    if [ -n "$_k_preload_list" ]; then
        _k_preload_list_arr=($_k_preload_list)
        for ((i=$((${#_k_preload_list_arr[*]}-1)); i>=0; i--)); do
           _k_unload ${_k_preload_list_arr[$i]}
        done
    fi
}

_k_list() {
  declare -F -p | cut -d " " -f 3 | grep "^_k_"
}

_k_list_lib() {
  declare -F -p | cut -d " " -f 3 | grep "^_k_loaded_" | sed "s#^_k_loaded_##g"
}

_k_function_list() {
  local ln  lib_name
  lib_name=$1
  if [ -n "$lib_name" ]; then
    grep "^_k_" $_K_LIB/${tag}${lib_name}.so | awk '/ \(\)\{$/ || / \(\) \{$/ || /\(\)\{$/ || /\(\) \{$/ || /\(\) $/ {print $1 }' | sed "s/(){//g" | sed "s/()//g" | sed "s/{//g" | sed "s/()//g" | sort
  else
    echo "<lib name>"
  fi
}

_k_avail() {
  local ln
  for ln in  $(ls $_K_LIB/${tag}*.so); do
        basename $ln | sed -e 's/^k//g' -e 's/\.so$//g'
  done
}

_k_find_function() {
  local func_name
  func_name=$1
  if [ -n "$func_name" ]; then
    for libname in $( _k_avail ); do
        _k_function_list $libname | grep -w $func_name >& /dev/null && echo "Filename : $_K_LIB/k${libname}.so"
    done
    typeset -f $func_name
  else
    echo "<function name>"
  fi
}

_k_version() {
  local name
  name=$1
  if [ -n "$name" ] ;then
     if [ -f $_K_LIB/${tag}${name}.so ]; then
         echo "$(head -n 10 $_K_LIB/${tag}${name}.so | grep "^#\$lib_ver\$:" | awk -F: '{print $2}')"
         return 0
     fi
  else
     echo "_k_version <lib name>"
  fi
  return 1
}

_k_loaded_misc(){
   local null
}

_k_misc_screen_get_session() {
  sessions=( )
  [ -d /var/run/screen/S-$(id -u -n) ] && sessions=( $(ls /var/run/screen/S-$(id -u -n)/ ) )

  _new_sessions=( $(ls /var/run/screen/S-$(id -u -n)/) )
  i=$(expr ${#_new_sessions[*]} - 1)
  while [ 0 -le $i ]; do
    if [ "${sessions[$i]}" != "${_new_sessions[$i]}" ]; then
       echo ${_new_sessions[$i]}
       break
    fi
    i=$(expr $i - 1)
  done
}

_k_misc_screen() { #run command on the screen
  local _opt _cmd
  _opt=$(_k_opt -o 1 0 "$*") && shift 2
  _cmd=$*

  while [ 1 ]; do
    [ -f /tmp/S-$(id -u -n).lock ] || break
    sleep 1
  done
  touch /tmp/S-$(id -u -n).lock

  if [ -n "$_cmd" ]; then
    if [ "$_opt" == "b" ]; then
     screen -d -m $_cmd
    elif [ "$_opt" == "lb" ];then
     screen -L -d -m $_cmd
    elif [ "$_opt" == "l" ]; then
     screen -L $_cmd
    else
     screen $_cmd
    fi
    sleep 0.1
    screen_session=$(_k_misc_screen_get_session)
    rm -f /tmp/S-$(id -u -n).lock
    [ -n "$screen_session" ] || return 1
    echo $screen_session
    return 0
  else
     error_return "_k_screen [ -o <option> ] <cmd> [ <opt of cmd>]"
  fi
}

_k_misc_braket() {
   IN=( $* )
   if [ ${#IN[*]} -ge 1 ]; then

     for A in ${IN[*]} ; do
       if echo $A | grep "\[" >& /dev/null ; then
         fval=$(echo $A | awk -F\[ '{print $1}' )
         vval=$(echo $A | awk -F\[ '{print $2}' | sed 's/]//g')

         ranges=( $(echo $vval | sed 's/,/ /g') )

         for i in $(seq 0 $(( ${#ranges[*]} - 1 )) ); do
           echo ${ranges[$i]} | grep "-" >&/dev/null && (
             start=$(echo ${ranges[$i]} | awk -F- '{print $1}')
             end=$(echo ${ranges[$i]} | awk -F- '{print $2}')
             strlen=${#start}
             for m in $(seq $start $end); do
               printf "%s%0${strlen}d\n" "$fval" "$m"
             done
           ) || echo ${fval}${ranges[$i]}
         done
       else
         echo $A
       fi
     done
   fi
}

_k_misc_is_num() {
    local src
    src=$@
    [ -n "$src" ] || return 1
    if [ "$(echo $src | sed "s/^[-+0-9][0-9.]*//g" | wc -c 2> /dev/null)" == "1" ]; then
       echo 1
       return 0
    else
       echo 0
       return 1
    fi
}

_k_misc_skip_blank(){
   local in
   in="$*"
   echo $(echo $in | sed 's/\ //g')
}

_k_opt_find() {
  local z opts find n
  find=${@:1:1}
  opts=("${@:2}")
  [ $# -lt 2 ] && error_return "_k_opt <find> <opts>"
  for ((z=0; z<${#opts[@]}; z++)); do 
    if [ "$find" == "${opts[$z]}" ]; then
      echo "$z"
      return 0
    fi
  done
  return 1
}

#_k_opt_end <num> <opts>
_k_opt_end() {
   local opts num get total
   num=${@:1:1}
   opts=("${@:2}")
   total=$((${#opts[@]}-1))
   opt_out=()
   if [ ! -n "$num" ]; then
       echo "${opts[@]}"
       return 0
   elif [ "$num" == "all" -o "$num" == "0" ]; then
       fnum=0
   elif (($num>=1)); then
       fnum=$(($total-$num+1))
   fi
   for ((z=$total; z >= $fnum; z--)); do
       echo "${opts[$z]}" | grep "^-" >& /dev/null && break 
       [ "${get[*]}" ] && get=("${opts[$z]}" "$get") || get=("${opts[$z]}");
   done
   if [ -n "${get[*]}" ]; then
       echo "${get[*]}"
       opt_out=("${get[@]}")
       export opt_out
       return 0
   else
       return 1
   fi
}

_k_opt() {
    local input find num get ro opts
    find="${@:1:1}"
    num="${@:2:1}"
    ro="${@:3:1}"
    opts=( "${@:4}" )

    opt_out=()

    [ "$find" == "--help" ] && num=0
    [ -n "$num" ] || num=1
    num_input=${#opts[@]}
    for ((i=0;i<$num_input;i++)); do
       if [ "${opts[$i]}" == "$find" ]; then
          unset opts[$i]
          if [ "$num" == "0" ]; then
             get[0]="help"
             break
          elif [ "$num" == "all" ]; then
             fnum=$(($num_input-1))
          elif (($num>0)); then
             fnum=$(($num+$i))
             (($fnum>=$num_input)) && return 1
          fi

          for ((z=$(($i+1)); z <=$fnum; z++)); do
                 if echo ${opts[$z]} | grep "^-" >/dev/null; then
                    [ "$num" == "all" ] && break || return 1
                 else
                    [ -n "${get[*]}" ] && get=("${get[@]}" "${opts[$z]}") || get=("${opts[$z]}")
                    unset opts[$z]
                 fi
          done
       fi
    done

    if [ -n "${get[*]}" ]; then
          if [ "$ro" == "1" ]; then
              opts=("${opts[@]}")
              echo "${opts[@]}"
              opt_out=("${opts[@]}")
          elif [ "$ro" == "2" ]; then
              opts=("${opts[@]}")
              echo "${get[@]}|${opts[@]}"
              opt_out=("${get[@]}" "|" "${opts[@]}")
          else
              if [ "${get[*]}" != "help" ]; then
                   echo "${get[@]}"
                   opt_out=("${get[@]}")
              fi
          fi
          export opt_out
          return 0
    else
          return 1
    fi
}

_k_make_hostname() {
   local group_name hosts
   _line_type=0
   _k_opt -l 0 0 "$@" >/dev/null && _line_type=1
   _k_opt -w 0 0 "$@" >/dev/null && _line_type_word=1
   group_name=$(_k_opt -g 1 0 "$@")
   hosts=$(_k_opt -h 1 0 "$@")
   if [ -n "$group_name" ]; then
     _k_get_all_hostname $group_name
   elif [ -n "$hosts" ]; then
     _hosts=$(_k_misc_braket $hosts)

     if [ "$_line_type" == "1" ]; then
      if [ "$_line_type_word" == "1" ]; then
          echo $_hosts | sed "s/ /,/g"
      else
          echo $_hosts
      fi
     else
      for nh in $_hosts; do
       echo $nh
      done
     fi
   else
     _k_get_all_hostname
   fi
}

_k_get_all_hostname() {
   group_name=$1
   if [ -f /etc/hosts ]; then
      if [ -n "$group_name" ]; then
         if [ "$KGT_HOSTNAME_DASH" == "1" ]; then
            grep -v -e "^127.0.0.1" -e "^#" -e "^::1" /etc/hosts | grep " ${group_name}-[0-9]" | awk '{print $2}' | while read line; do 
               [ "$(echo "$line" | grep -o "-" | wc -l)" == "1" ] && echo $line
            done
         else
            grep -v -e "^127.0.0.1" -e "^#" -e "^::1" /etc/hosts | grep " ${group_name}[0-9]" | awk '{print $2}' | while read line; do
               [ "$(echo "$line" | grep -o "-" | wc -l)" == "1" ] && echo $line
            done
         fi
      else
         grep -v -e "^127.0.0.1" -e "^#" -e "^::1" /etc/hosts | awk '{print $2}' | while read line; do
            [ "$(echo "$line" | grep -o "-" | wc -l)" == "1" ] && echo $line
         done
      fi
   fi
}

_k_net_ip2str() {
    local num
    num=$1
    [ -n "$num" ] || error_exit "input not found"
    echo $(( $(( $num/$((256*256*256)) ))% 256)).$(( $(($num/$((256*256)) ))%256)).$(( $(($num/256)) % 256)).$(($num%256))
}

_k_net_str2ip() {
    [ -n "$1" ] || error_exit "input not found"
    ip=( $(echo $1 | sed 's/\./ /g') )
    echo $(( $((256*256*256*${ip[0]})) + $((256*256*${ip[1]})) + $((256*${ip[2]})) +${ip[3]} ))
}

_k_net_add_ip() {
    [ -n "$1" ] || error_exit "IP not found"
    [ -n "$2" ] || error_exit "add value not found"
    echo $(_k_net_ip2str $(( $(_k_net_str2ip $1) + $2 )) )
}

_k_net_ip() {
    network=$1
    netmask=$2
    network_ip=($(echo $network | sed "s/\./ /g"))
    zz=0
    for ii in $(echo $netmask | sed "s/\./ /g"); do
       [ "$ii" == "0" ] && break
       (( $zz > 0 )) && echo "."
       echo "${network_ip[$zz]}"
       zz=$(($zz+1))
    done
}

_k_misc_get_realpath() {
    local src
    src=$1
    while [ 1 ]; do
        get_file=$(readlink -f $src)
        if [ ! -L "$get_file" ]; then
            echo "$get_file"
            break
        else
            src="$get_file"
        fi
    done
}
